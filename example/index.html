<!-- TODO: 
        x Templating
        - A Start modal
        - A Gameover Modal
        x Cookies fo highscore
        x Loop registering
        - Clean up
-->

<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Game Frame Example</title>
        <meta name="description" content="TODO"/>
        <meta name="viewport" content="width=device-width" />
        <style type="text/css">
            #game, #templates {
                display: none;
            }
            #scoreboard {
                position: absolute;
            }

            * {
                margin: 0;
                padding: 0;
            }
            html, body {
                width:100%;
                height: 100%;
            }
        </style>
    </head>
    <body>


    <svg id="game">
            <circle id="ball" class="movable" vy=.5 vx=.3 cx=250 cy=150 r=70 img="http://i0.kym-cdn.com/entries/icons/facebook/000/013/564/aP2dv.jpg"> </circle>
            <rect id="player" class="static" width="500" height="50" x=300 y=480> </rect>
            <rect id="floor" class="static" width="2000" height="50" x=1000 y=500> </rect>
    </svg>

    <svg id="templates">
        <rect class="static block" width="100" height="50" x=25 y=25> </rect>
    </svg>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/PhysicsJS/0.7.0/physicsjs-full.min.js"></script>
    <script src="interactive-custom.js"></script>
    <script type="text/javascript">

        let game = document.getElementById('game');
        let templates = document.getElementById('templates');
        let children = game.children;

        var collisions = {};

        let keyhash = function(A,B){
            return [A, B].sort().join();
        }

        let collision = function(A,B,f){
            var key = keyhash(A,B);
            collisions[key] = f;
        }

        let keyEvents = {};

        let registerKeys = function(id, keys){
            for (var key in keys) {
                if(!(key in keyEvents)){
                    keyEvents[key] = {};
                }
                keyEvents[key][id] = keys[key];
            }
        }

        let loops = [];

        let registerLoops = function(f){
            loops[loops.length] = f;
        }

        let taxonomy = {
            "circle" : function(el){
                return Physics.body("circle",{
                    name: el.classList.contains("movable") ? "movable" : "",
                    treatment: el.classList.contains("static") ? "static" : "dynamic",
                    x: (el.attributes["cx"] || el.attributes["x"] || 0).value | 0,
                    y: (el.attributes["cy"] || el.attributes["y"] || 0).value | 0,
                    radius: (el.attributes["r"] || 0).value | 0,
                    vy: (el.attributes["vy"] || 0).value,
                    vx: (el.attributes["vx"] || 0).value,
                });
            },
            "rect" : function(el){
                return Physics.body("rectangle",{
                    name: el.classList.contains("movable") ? "movable" : "",
                    treatment: el.classList.contains("static") ? "static" : "dynamic",
                    width: (el.attributes["width"] || 0).value | 0,
                    height: (el.attributes["height"] || 0).value | 0,
                    x: (el.attributes["x"] || 0).value | 0,
                    y: (el.attributes["y"] || 0).value | 0,
                    vy: (el.attributes["vy"] || 0).value,
                    vx: (el.attributes["vx"] || 0).value,
                });
            },
            "g" : function(el){
                var contained = [];
                for(var i = 0; i < el.children.length; i++){
                    contained[i] = createObj(el.children[i]);
                }
                if (contained.length == 0) return;
                return Physics.body("compound",{
                    name: "movable" in el.classList ? "movable" : "",
                    //treatment: el.classList.contains("static") ? "static" : "dynamic",
                    x: (el.attributes["x"] || 0).value | 0,
                    y: (el.attributes["y"] || 0).value | 0,
                    children: contained
                });
            }
        };

        let clipboard = document.createElement("canvas");
        let context = clipboard.getContext("2d");
        let scoreboard = document.createElement("div");
        scoreboard.id = "scoreboard";
        document.body.appendChild(scoreboard);


        let clip = {
            "rect": (obj, img)=>{
                return function(){

                    // Adjust to size
                    clipboard.width = obj.width;
                    clipboard.height = obj.height;

                    // scale. forget aspect ratio
                    context.drawImage(img, 0, 0, img.width, img.height,
                                    0,0, obj.width, obj.height);

                    // Set the object src
                    obj.view.src = clipboard.toDataURL("image/png");
                }
            },
            "circle": (obj, img)=>{
                return function(){

                    let radius = obj.geometry.radius;

                    // Adjust to size
                    clipboard.width = radius * 2;
                    clipboard.height = radius * 2;

                    context.save();
                    context.arc(radius, radius, radius, 0, 2 * Math.PI, false);
                    context.clip();

                    // scale. forget aspect ratio
                    context.drawImage(img, 0, 0, img.width, img.height,
                                    0,0, radius * 2, radius * 2);

                    // Set the object src
                    obj.view.src = clipboard.toDataURL("image/png");
                }
            }
        }

        let createObj = function(el){
            let type = el.nodeName.toLowerCase();
            let f = taxonomy[type];
            if(f == undefined){
                console.warn("Woops, element " + type + " not known.");
                return;
            }
            let obj = f(el)
            let src = (el.attributes["img"] || 0).value;
            if(src && clip[type]){
                let img = new Image();
                obj.view = new Image();
                img.setAttribute('crossOrigin', 'anonymous');
                img.onload = clip[type](obj, img);
                img.src = src;
            }
            return obj;
        }

        var world;

        let buildObj = function(el){
            var obj = createObj(el);
            if(obj){
                var ids = [];
                if(!el.id){
                    el.id = "generated_" + (seed++);
                }
                lookup["#" + el.id] = obj;
                ids[ids.length] = "#" + el.id;
                for (var j = 0; j < el.classList.length; j++) {
                    var c = "." + el.classList[j];
                    if(!(c in lookup)){
                        lookup[c] = []
                    }
                    lookup[c][lookup[c].length] = obj;
                    ids[ids.length] = c;
                }
                el.classList;
                obj.ids = ids;
                world.add(obj);
            }
        }

        let template = function(id, x, y){
            var el = templates.querySelector(id);
            el.setAttribute('x', (x || el.attributes["x"]) | 0);
            el.setAttribute('y', (y || el.attributes["y"]) | 0);
            buildObj(el);
        }

        var viewportBounds = Physics.aabb(0, 0, window.innerWidth, window.innerHeight)
        var edgeBounce = Physics.behavior('edge-collision-detection', {
            aabb: viewportBounds
            ,restitution: 0.99
            ,cof: 1.0
        });

        var lookup = {};
        var seed = 0;

        var remove = function(obj){
            obj._world.remove(obj);
        }

        Physics({
            // set the timestep
            timestep: 1000.0 / 160,
            // maximum number of iterations per step
            maxIPF: 2,
        }, function(w){

            world = w;

            for (var i = 0; i < children.length; i++) {
                buildObj(children[i]);
            }
            console.log(lookup);
            var renderer = Physics.renderer('canvas', {
                el: 'viewport',
                width: 500,
                height: 300,
                meta: false, // don't display meta data
            });

            // add the renderer
            world.add(renderer);
            world.on('step', function(){

                for (var i = 0; i < loops.length; i++) {
                    loops[i](lookup);
                }
                // Note: equivalent to just calling world.render() after world.step()
                world.render();
            });

            // collisions
            world.on('collisions:detected', function(data){
                var col;
                for (var i = data.collisions.length - 1; i >= 0; i--) {
                    col = data.collisions[i];
                    if(!(col.bodyA.ids && col.bodyB.ids)) continue;
                    for (var j = 0; j < col.bodyA.ids.length; j++) {
                        for (var k = 0; k < col.bodyB.ids.length; k++) {
                            var hash = keyhash(col.bodyA.ids[j], col.bodyB.ids[k]);
                            if(hash in collisions) {
                                datum = {};
                                datum[col.bodyA.ids[j]] = col.bodyA;
                                datum[col.bodyB.ids[k]] = col.bodyB;
                                collisions[hash](datum);
                            }
                        }
                    }
                }
            });

            // collisions
            world.on('interact:click', function(data){
                var key = "click";
                console.log("Here")
                if(key in keyEvents){
                    for (var id in keyEvents[key]) {
                        keyEvents[key][id](data.body, lookup);
                    }
                }

            });

            world.add([
                Physics.behavior('body-collision-detection', { checkAll: false }),
                Physics.behavior('sweep-prune'),
                Physics.behavior('body-impulse-response'),
                //Physics.behavior('constant-acceleration'),
                edgeBounce,
                Physics.behavior('interactive-custom', { el: renderer.el }).applyTo(world.find({ name: 'movable' }))
            ]);

            // subscribe to ticker to advance the simulation
            Physics.util.ticker.on(function( time, dt ){
                world.step(time);
                //console.log("aye")
            });

            // start the ticker
            Physics.util.ticker.start();


            // resize events
            window.addEventListener('resize', function () {

                // as of 0.7.0 the renderer will auto resize... so we just take the values from the renderer
                viewportBounds = Physics.aabb(0, 0, renderer.width, renderer.height);
                // update the boundaries
                edgeBounce.setAABB(viewportBounds);

            }, true);
        });

        var keys = {};
        var special = {
            38: "up",
            40: "down",
            37: "left",
            39: "right",
        }

        let getkey = function(code){
            if(code in special){
                return special[code];
            }
            return String.fromCharCode(code);
        }

        document.addEventListener('keydown', function(e){
            var key = getkey(e.keyCode);
            keys[key] = true;
            if(key in keyEvents){
                for (var id in keyEvents[key]) {
                    keyEvents[key][id](lookup[id]);
                }
            }
        });
        document.addEventListener('keyup', function(e){
            keys[getkey(e.keyCode)] = false;
        });

        var _score = 0;        

        let score = function(value){
            _score += value || 0;
            if(score > localStorage["highscore"]){
                localStorage.setItem("highscore",_score);
            }
            scoreboard.innerHTML = "Score: "+ _score;
        }

        score(0);

        var _score2 = 0;        

        let score2 = function(value){
            _score2 += value || 0;
            if(score2 > localStorage["highscore2"]){
                localStorage.setItem("highscore2",_score2);
            }
            scoreboard2.innerHTML = "Score 2: "+ _score2;
        }

        score2(0);

        // -------- User defined

        collision("#floor", "#ball", function(data, lookup){
            alert("Game over")
        })

        collision(".block", "#ball", function(data, lookup){
            remove(data[".block"]);
            score(10);
        })

        registerKeys("#player", {
            'right': function(player, lookup){
                player.state.pos.x += 25;
            },
            'left': function(player, lookup){
                player.state.pos.x -= 25;
            }
        })

        registerKeys("#ball", {
            'up': function(player, lookup){
                player.state.angular.vel += .01;
            },
            'down': function(player, lookup){
                player.state.angular.vel -= .01;
            }
        })

        registerKeys(".block", {
            'click': function(block, lookup){
                remove(block);
            }
        })

        registerLoops(function(lookup){
            // Do stuff
        });

        for (var i = 0; i < 10; i++) {
            template(".block", i * 100, 50);
        }

    </script>

    </body>
</html>
